import 'dart:typed_data';

import 'package:sector/sector.dart';
import 'package:sector/src/internal.dart';

/// A dense grid implementation using a 1-dimensional [List] to store elements.
///
/// This implementation is the default grid type returned by the constructors in
/// the [Grid] interface. It is a row-major dense grid, where each row is stored
/// contiguously in memory; the most common layout for a grid, and is often the
/// most efficient for most use-cases.
///
/// ## Performance
///
/// All single element access operations using a [Pos] are `O(1)` operations,
/// and iteration over rows and columns are `O(n)` operations, where `n` is the
/// number of rows or columns. This includes:
///
/// - [get], [getUnchecked];
/// - [set], [setUnchecked].
///
/// As row-major iterating over [rows] is much more efficient than [columns].
///
/// {@category Grids}
final class ListGrid<T> with Grid<T> {
  /// Creates a new grid with the given [width] and [height].
  ///
  /// Each element of the grid is initialized to [fill].
  ///
  /// The [width] and [height] must be non-negative.
  factory ListGrid.filled(int width, int height, T fill) {
    return ListGrid._(List.filled(width * height, fill), width: width);
  }

  /// Creates a new grid with the given [width] and [height].
  ///
  /// Each element of the grid is generated by calling [generator] with the
  /// position of the element, where the element at position `(x, y)` is
  /// `generator(Pos(x, y))`.
  ///
  /// The [width] and [height] must be non-negative.
  factory ListGrid.generate(int width, int height, T Function(Pos) generator) {
    if (width == 0 || height == 0) {
      return ListGrid.empty();
    }
    final list = List.generate(
      width * height,
      (index) {
        final pos = Pos(index % width, index ~/ width);
        return generator(pos);
      },
      growable: false,
    );
    return ListGrid._(list, width: width);
  }

  /// Creates a new grid with the same elements and positions as [other].
  ///
  /// The new grid is a shallow copy of the existing grid.
  factory ListGrid.fromGrid(Grid<T> other) {
    if (other is ListGrid<T>) {
      return ListGrid._(
        List.of(other._elements, growable: false),
        width: other.width,
      );
    }
    return ListGrid.generate(other.width, other.height, other.getUnchecked);
  }

  /// Creates a new grid from the provided [rows] of columns of elements.
  ///
  /// Each element in `rows`, a column, must have the same length, and the
  /// resulting grid will have a width equal to the number of columns, and a
  /// height equal to the length of each column.
  ///
  /// The grid is initialized with the elements in the rows, where the element
  /// at index `(x, y)` is `rows.elementAt(y).elementAt(x)`.
  factory ListGrid.fromRows(Iterable<Iterable<T>> rows) {
    if (rows.isEmpty) {
      return const ListGrid.empty();
    }
    final width = rows.first.length;
    final elements = expandEqualLength(rows);
    return ListGrid._(List.of(elements, growable: false), width: width);
  }

  /// Creates a new grid from the provided [elements] in row-major order.
  ///
  /// The grid will have a width of [width], and the number of rows is
  /// determined by the number of elements divided by the width, which must be
  /// an integer.
  factory ListGrid.fromIterable(
    Iterable<T> elements, {
    required int width,
  }) {
    final elementslist = List.of(elements, growable: false);
    if (elementslist.length % width != 0) {
      throw ArgumentError.value(
        width,
        'width',
        'The number of elements must be a multiple of width.',
      );
    }
    return ListGrid._(elementslist, width: width);
  }

  /// Creates a new grid backed by the provided [elements] in row-major order.
  ///
  /// The grid will have a width of [width], and the number of rows is
  /// determined by the number of elements divided by the width, which must be
  /// an integer.
  ///
  /// Changes to the provided list will be reflected in the grid, and changes
  /// to the grid will be reflected in the list accordingly, with `elements[i]`
  /// being the element at position `Pos(i % width, i ~/ width)`.
  ///
  /// > [!WARNING]
  /// > The provided list must not be modified in a way that violates the
  /// > constraints of the grid, such as changing the length of the list, or
  /// > changing the elements in a way that violates the width of the grid.
  /// >
  /// > If the list will support appending rows or columns at runtime, access
  /// > must carefully avoid modifying the length during iteration, including by
  /// > [ListGrid.columns], [ListGrid.rows], or any other iterative operation.
  ///
  /// ## Performance
  ///
  /// This constructor exists in order to avoid copying the elements of the list
  /// into a new list, which can be expensive for large lists, or for using a
  /// different sub-type of [List] such as [Uint8List] or [Float32List].
  ///
  /// ## Example
  ///
  /// ```dart
  /// final buffer = Uint8List(9);
  /// final grid = ListGrid.withList(buffer, width: 3);
  /// print(grid.get(Pos(1, 1))); // 0
  ///
  /// grid.set(Pos(1, 1), 42);
  /// print(buffer); // [0, 0, 0, 0, 42, 0, 0, 0, 0]
  /// ```
  factory ListGrid.withList(List<T> elements, {required int width}) {
    if (elements.length % width != 0) {
      throw ArgumentError.value(
        width,
        'width',
        'The number of elements must be a multiple of width.',
      );
    }
    return ListGrid._(elements, width: width);
  }

  /// Creates a new empty grid.
  ///
  /// The grid has a width and height of `0` and will not contain any elements.
  const ListGrid.empty() : this._(const [], width: 0);

  const ListGrid._(this._elements, {required this.width});
  final List<T> _elements;

  @override
  final int width;

  @override
  int get height => width == 0 ? 0 : _elements.length ~/ width;

  @override
  @pragma('vm:prefer-inline')
  T getUnchecked(Pos pos) {
    return _elements[rowMajor1D(pos, width: width)];
  }

  @override
  @pragma('vm:prefer-inline')
  void setUnchecked(Pos pos, T element) {
    _elements[rowMajor1D(pos, width: width)] = element;
  }

  @override
  Iterable<Iterable<T>> get rows => _ListGridRows(this);
}

final class _ListGridRows<E> extends FixedLengthIterable<Iterable<E>> {
  _ListGridRows(this._grid);
  final ListGrid<E> _grid;

  @override
  int get length => _grid.height;

  @override
  Iterable<E> elementAt(int index) {
    RangeError.checkValidIndex(index, this);

    final start = rowMajor1D(Pos(0, index), width: _grid.width);
    return _grid._elements.getRange(start, start + _grid.width);
  }
}
